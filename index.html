<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #111827;
            --bg-secondary: #1f2937;
            --bg-tertiary: #374151;
            --bg-tertiary-hover: #4b5563;
            --text-primary: #ffffff;
            --text-secondary: #9ca3af;
            --text-accent: #fb923c;
            --accent-primary: #f97316;
            --accent-primary-hover: #ea580c;
            --accent-danger: #dc2626;
            --accent-danger-hover: #b91c1c;
        }

        [data-theme="light"] {
            --bg-primary: #f9fafb;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e5e7eb;
            --bg-tertiary-hover: #d1d5db;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --text-accent: #f97316;
            --accent-primary: #f97316;
            --accent-primary-hover: #ea580c;
            --accent-danger: #ef4444;
            --accent-danger-hover: #dc2626;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
            padding-bottom: 80px; 
            overflow-x: hidden;
            position: relative;
        }
        
        #background-effects {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: -1;
        }
        
        .smoke {
            position: absolute;
            bottom: -200px;
            background: rgba(251, 146, 60, 0.05);
            border-radius: 50%;
            filter: blur(60px);
            animation-timing-function: linear;
            animation-iteration-count: infinite;
        }

        .smoke-1 {
            width: 300px;
            height: 300px;
            left: 5%;
            animation-name: smoke-rise-1;
            animation-duration: 25s;
        }

        .smoke-2 {
            width: 400px;
            height: 400px;
            left: 40%;
            animation-name: smoke-rise-2;
            animation-duration: 35s;
            animation-delay: 5s;
        }
        
        .smoke-3 {
            width: 250px;
            height: 250px;
            left: 75%;
            animation-name: smoke-rise-3;
            animation-duration: 20s;
            animation-delay: 10s;
        }
        
        @keyframes smoke-rise-1 {
            0% { transform: translateY(0) scale(1) translateX(0); opacity: 0; }
            20% { opacity: 0.1; }
            100% { transform: translateY(-120vh) scale(1.8) translateX(20px); opacity: 0; }
        }
        @keyframes smoke-rise-2 {
            0% { transform: translateY(0) scale(1) translateX(0); opacity: 0; }
            20% { opacity: 0.08; }
            100% { transform: translateY(-120vh) scale(1.6) translateX(-30px); opacity: 0; }
        }
        @keyframes smoke-rise-3 {
            0% { transform: translateY(0) scale(1) translateX(0); opacity: 0; }
            20% { opacity: 0.12; }
            100% { transform: translateY(-120vh) scale(1.9) translateX(10px); opacity: 0; }
        }

        .themed {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border-color: var(--bg-tertiary);
        }
        .themed-input, textarea.themed-input {
             background-color: var(--bg-tertiary);
             color: var(--text-primary);
        }
        .themed-input::placeholder {
            color: var(--text-secondary);
        }
        .themed-button-primary {
            background-color: var(--accent-primary);
            color: white;
        }
        .themed-button-primary:hover {
            background-color: var(--accent-primary-hover);
        }
        .themed-button-secondary {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }
        .themed-button-secondary:hover {
            background-color: var(--bg-tertiary-hover);
        }
        .themed-button-danger {
            background-color: var(--accent-danger);
            color: white;
        }
        .themed-button-danger:hover {
            background-color: var(--accent-danger-hover);
        }
        .themed-text-accent { color: var(--text-accent); }
        .themed-text-secondary { color: var(--text-secondary); }
        .themed-icon-button { color: var(--text-secondary); }
        .themed-icon-button:hover { color: var(--text-accent); }
        .control-active {
            color: var(--text-accent) !important;
        }
        .dragging {
            opacity: 0.5;
            background-color: var(--bg-tertiary);
        }
        .scrubber-handle {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background-color: white;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            margin-left: -0.5rem; 
            cursor: grab;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .progress-bar-wrapper:hover .scrubber-handle {
            opacity: 1;
        }
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .line-clamp-3 {
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .transform.hover\\:scale-102:hover {
            transform: scale(1.02);
        }
        .transform.hover\\:scale-105:hover {
            transform: scale(1.05);
        }
        .transform.hover\\:scale-110:hover {
            transform: scale(1.1);
        }
        
        /* Custom range slider styling */
        .themed-slider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #e5e7eb;
            outline: none;
            border-radius: 3px;
            transition: opacity 0.2s;
        }
        
        .dark .themed-slider {
            background: #374151;
        }
        
        .themed-slider:hover {
            opacity: 1;
        }
        
        .themed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #f97316;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            border: 2px solid white;
        }
        
        .themed-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #f97316;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body class="antialiased">
    <div id="background-effects">
        <div class="smoke smoke-1"></div>
        <div class="smoke smoke-2"></div>
        <div class="smoke smoke-3"></div>
    </div>

    <div id="app" class="container mx-auto max-w-4xl p-4 sm:p-6 lg:p-8 pb-24">
        <header class="mb-6">
            <div class="flex justify-between items-center">
                <div class="flex items-center gap-3">
                    <img src="logo.png"
                         alt="Fire Player Logo"
                         class="h-8 w-8"
                         style="object-fit: contain;"
                         onerror="this.onerror=null; this.src='https://cdn.pixabay.com/photo/2022/07/21/11/48/fire-7336074_960_720.png';">
                    <h1 class="text-2xl font-bold themed-text-accent whitespace-nowrap">Fire Player</h1>
                </div>
                <div class="flex items-center gap-3">
                    <button id="showUploadFormBtn" class="themed-button-primary font-bold py-2 px-4 rounded-md transition-transform duration-200 transform hover:scale-105">
                        Add New
                    </button>
                </div>
            </div>
        </header>

        <div id="uploadSection" class="themed rounded-lg p-6 mb-8 shadow-lg hidden">
            <h2 class="text-2xl font-semibold mb-4">Add New Podcast</h2>
            <div class="space-y-4">
                 <div>
                    <label for="fileInput" class="w-full flex-grow themed-button-secondary font-bold py-3 px-6 rounded-md cursor-pointer hover:bg-gray-600 transition-colors duration-200 truncate block text-center">
                        Choose File to Upload...
                    </label>
                     <input type="file" id="fileInput" accept="audio/*" class="hidden">
                 </div>
                 <div class="flex items-center space-x-2">
                    <hr class="flex-grow border-t border-gray-600">
                    <span class="themed-text-secondary">OR</span>
                    <hr class="flex-grow border-t border-gray-600">
                 </div>
                 <div>
                    <label for="urlInput" class="block text-sm font-medium themed-text-secondary mb-1">Import from URL</label>
                    <div class="flex flex-col sm:flex-row items-center space-y-4 sm:space-y-0 sm:space-x-4">
                        <input type="text" id="urlInput" placeholder="Paste an audio URL here..." class="w-full flex-grow themed-input rounded-md px-4 py-3">
                        <button id="importUrlBtn" class="w-full sm:w-auto flex-shrink-0 themed-button-secondary font-bold py-3 px-6 rounded-md">Import</button>
                    </div>
                </div>
                 <div class="flex items-center space-x-2">
                    <hr class="flex-grow border-t border-gray-600">
                    <span class="themed-text-secondary">OR</span>
                    <hr class="flex-grow border-t border-gray-600">
                 </div>
                 <div>
                     <label for="rssInput" class="block text-sm font-medium themed-text-secondary mb-1">Add RSS Feed</label>
                    <div class="mt-1 flex flex-col sm:flex-row items-center space-y-4 sm:space-y-0 sm:space-x-4">
                        <input type="text" id="rssInput" placeholder="Paste an RSS Feed URL here..." class="w-full flex-grow themed-input rounded-md px-4 py-3">
                        <input type="number" id="rssLimit" min="1" max="10" value="5" class="w-20 themed-input rounded-md px-4 py-3">
                        <button id="addRssBtn" class="w-full sm:w-auto flex-shrink-0 themed-button-secondary font-bold py-3 px-6 rounded-md">Import</button>
                    </div>
                 </div>
            </div>
            <div id="uploadProgressContainer" class="mt-4 hidden">
                 <div class="w-full bg-gray-700 rounded-full h-2.5">
                    <div id="uploadProgressBar" class="h-2.5 rounded-full" style="width: 0%; background-color: var(--text-accent);"></div>
                </div>
            </div>
        </div>
        


        <div>
            <!-- Tab Navigation -->
            <div class="flex border-b border-gray-600 mb-6">
                <button id="libraryTab" class="tab-button px-4 py-2 font-semibold themed-text-accent border-b-2 border-orange-500">
                    My Library
                </button>
                <button id="rssEpisodesTab" class="tab-button px-4 py-2 font-semibold themed-text-secondary hover:themed-text-accent">
                    RSS Episodes
                </button>
                <button id="manageFeedsTab" class="tab-button px-4 py-2 font-semibold themed-text-secondary hover:themed-text-accent">
                    Manage Feeds
                </button>
            </div>
            
            <!-- Library Content -->
            <div id="libraryContent">
                <div id="podcastListContainer">
                    <p id="loadingMessage" class="themed-text-secondary text-center py-4">Your library is empty. Upload your first podcast!</p>
                </div>
            </div>
            
            <!-- RSS Episodes Content -->
            <div id="rssEpisodesContent" class="hidden">
                <div id="rssEpisodesContainer">
                    <p id="rssLoadingMessage" class="themed-text-secondary text-center py-4">No RSS episodes imported yet.</p>
                </div>
            </div>
            
            <!-- Manage Feeds Content -->
            <div id="manageFeedsContent" class="hidden">
                <div class="themed rounded-lg p-6 mb-8 shadow-lg">
                    <h2 class="text-2xl font-semibold mb-4">Add New RSS Feed</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="manageFeedInput" class="block text-sm font-medium themed-text-secondary mb-1">RSS Feed URL</label>
                            <div class="mt-1 flex flex-col sm:flex-row items-center space-y-4 sm:space-y-0 sm:space-x-4">
                                <input type="text" id="manageFeedInput" placeholder="Paste an RSS Feed URL here..." class="w-full flex-grow themed-input rounded-md px-4 py-3">
                                <input type="number" id="manageFeedLimit" min="1" max="10" value="5" class="w-20 themed-input rounded-md px-4 py-3">
                                <button id="addManageFeedBtn" class="w-full sm:w-auto flex-shrink-0 themed-button-secondary font-bold py-3 px-6 rounded-md">Import</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="manageFeedsContainer">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-semibold">My Feeds</h2>
                        <button id="refreshManageFeedsBtn" class="themed-button-secondary px-4 py-2 rounded-md">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                            </svg>
                            Refresh All
                        </button>
                    </div>
                    <div id="manageFeedsList" class="space-y-2">
                        <p class="themed-text-secondary text-center py-4">No RSS feeds added yet.</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="playedContainer" class="mt-12 hidden">
            <h2 id="playedTitle" class="text-2xl font-semibold mb-4">Played</h2>
            <div id="playedListContainer"></div>
        </div>

        <!-- Fetch More Episodes Modal -->
        <div id="fetchMoreModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="themed rounded-lg p-6 max-w-md w-full mx-4">
                <h3 class="text-xl font-semibold mb-4">Fetch Older Episodes</h3>
                <div class="mb-4">
                    <p class="text-sm themed-text-secondary mb-2">Podcast: <span id="fetchModalPodcastName" class="themed-text-primary"></span></p>
                    <label for="fetchCount" class="block text-sm font-medium themed-text-secondary mb-2">Number of older episodes to fetch:</label>
                    <select id="fetchCount" class="w-full themed-input rounded-md px-3 py-2">
                        <option value="1">Last 1 episode</option>
                        <option value="2">Last 2 episodes</option>
                        <option value="3">Last 3 episodes</option>
                        <option value="4">Last 4 episodes</option>
                        <option value="5" selected>Last 5 episodes</option>
                        <option value="10">Last 10 episodes</option>
                        <option value="15">Last 15 episodes</option>
                        <option value="20">Last 20 episodes</option>
                        <option value="25">Last 25 episodes</option>
                    </select>
                </div>
                <div class="flex space-x-3">
                    <button id="fetchMoreConfirm" class="themed-button-primary px-4 py-2 rounded-md flex-1">
                        Fetch Episodes
                    </button>
                    <button id="fetchMoreCancel" class="themed-button-secondary px-4 py-2 rounded-md flex-1">
                        Cancel
                    </button>
                </div>
            </div>
        </div>

        <!-- Edit Feed Modal -->
        <div id="editFeedModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="themed rounded-lg p-6 max-w-md w-full mx-4">
                <h3 class="text-xl font-semibold mb-4">Edit RSS Feed</h3>
                <div class="mb-4">
                    <label for="editFeedName" class="block text-sm font-medium themed-text-secondary mb-2">Feed Name:</label>
                    <input type="text" id="editFeedName" class="w-full themed-input rounded-md px-3 py-2" placeholder="Enter feed name...">
                </div>
                <div class="mb-4">
                    <label for="editFeedUrl" class="block text-sm font-medium themed-text-secondary mb-2">Feed URL:</label>
                    <textarea id="editFeedUrl" rows="3" class="w-full themed-input rounded-md px-3 py-2" placeholder="Paste the full RSS feed URL here..."></textarea>
                </div>
                <div class="flex space-x-3">
                    <button id="editFeedSave" class="themed-button-primary px-4 py-2 rounded-md flex-1">
                        Save Changes
                    </button>
                    <button id="editFeedCancel" class="themed-button-secondary px-4 py-2 rounded-md flex-1">
                        Cancel
                    </button>
                </div>
            </div>
        </div>

        <audio id="audioPlayer" class="hidden"></audio>
        
        <!-- Audio Controls -->
        <div id="audioControls" class="fixed bottom-0 left-0 right-0 themed border-t z-40" style="border-color: var(--bg-tertiary-hover)">
            <!-- Now Playing Bar -->
            <div id="nowPlayingBar" class="flex items-center p-3 border-b hidden" style="border-color: var(--bg-tertiary-hover)">
                <div class="flex items-center flex-grow min-w-0">
                    <img id="nowPlayingArtwork" src="" class="w-12 h-12 rounded-lg object-cover mr-3">
                    <div class="flex-grow min-w-0">
                        <h4 id="nowPlayingTitle" class="font-semibold truncate text-sm">No track selected</h4>
                        <p id="nowPlayingTime" class="text-xs themed-text-secondary">00:00 / 00:00</p>
                    </div>
                </div>
                <div class="flex items-center space-x-2">
                    <!-- Main Controls -->
                    <button id="mainPrevBtn" class="themed-icon-button p-2 rounded-full">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                        </svg>
                    </button>
                    <button id="mainPlayPauseBtn" class="bg-orange-500 hover:bg-orange-600 rounded-full p-3 transition-all disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        <svg id="mainPlayIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        <svg id="mainPauseIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6" />
                        </svg>
                    </button>
                    <button id="mainNextBtn" class="themed-icon-button p-2 rounded-full">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                        </svg>
                    </button>
                </div>
            </div>
            
            <!-- Bottom Controls -->
            <div class="p-3">
                <div class="container mx-auto max-w-4xl flex justify-between items-center">
                    <div class="flex items-center space-x-4">
                        <button id="viewToggleBtn" class="themed-icon-button p-2 rounded-full">
                            <svg id="icon-grid-view" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" /></svg>
                            <svg id="icon-list-view" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16" /></svg>
                        </button>
                        <button id="themeToggleButton" class="themed-icon-button p-2 rounded-full transition-colors">
                            <svg id="theme-icon-dark" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                              <path stroke-linecap="round" stroke-linejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                            </svg>
                            <svg id="theme-icon-light" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                              <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                            </svg>
                        </button>
                        <button id="shuffleButton" class="themed-icon-button p-2 rounded-full transition-colors">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line></svg>
                        </button>
                        <button id="repeatButton" class="themed-icon-button p-2 rounded-full transition-colors">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path></svg>
                        </button>
                    </div>
                    
                    <div class="flex items-center space-x-4">
                        <!-- Volume Control -->
                        <div class="flex items-center space-x-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 themed-text-secondary" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.617.82L4.736 14H2a1 1 0 01-1-1V7a1 1 0 011-1h2.736l3.647-2.82a1 1 0 011 .896zM12 8a1 1 0 011.414 0A5.28 5.28 0 0115 12a5.28 5.28 0 01-1.586 4A1 1 0 0111.828 14.414A3.28 3.28 0 0013 12a3.28 3.28 0 00-1.172-2.414A1 1 0 0112 8z"/>
                                <path d="M14.657 2.929a1 1 0 011.414 0A9.969 9.969 0 0119 12a9.969 9.969 0 01-2.929 7.071 1 1 0 11-1.414-1.414A7.971 7.971 0 0017 12c0-2.21-.894-4.208-2.343-5.657a1 1 0 010-1.414z"/>
                            </svg>
                            <input type="range" id="volumeSlider" min="0" max="100" value="100" class="w-24 h-2 themed-slider rounded-lg appearance-none cursor-pointer">
                        </div>
                        <button id="speedControlButton" class="themed-icon-button p-2 rounded-full transition-colors font-bold text-sm w-12 h-8 flex items-center justify-center">1x</button>
                        <button id="settingsButton" class="themed-icon-button p-2 rounded-full transition-colors">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                              <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                              <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div id="messageBox" class="fixed bottom-24 right-5 bg-green-500 text-white py-2 px-4 rounded-lg shadow-lg opacity-0 transition-opacity duration-300 z-50">
            <p id="messageText"></p>
        </div>
        
        <div id="deleteModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50">
            <div class="themed rounded-lg p-8 shadow-2xl max-w-sm mx-auto">
                <h3 class="text-xl font-bold mb-4">Confirm Deletion</h3>
                <p class="themed-text-secondary mb-6">Are you sure you want to delete "<span id="podcastNameToDelete"></span>"? This action cannot be undone.</p>
                <div class="flex justify-end space-x-4">
                    <button id="cancelDelete" class="themed-button-secondary font-bold py-2 px-4 rounded-md transition-colors">Cancel</button>
                    <button id="confirmDelete" class="themed-button-danger font-bold py-2 px-4 rounded-md transition-colors">Delete</button>
                </div>
            </div>
        </div>
        
        <div id="settingsModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50 p-4">
            <div class="themed rounded-lg p-8 shadow-2xl max-w-lg lg:max-w-4xl w-full mx-auto max-h-full overflow-y-auto">
                <h3 class="text-xl font-bold mb-2">Setup & Configuration</h3>
                
                <div class="lg:flex lg:gap-8">
                    <div class="lg:flex-1 mb-6 p-4 rounded-lg border" style="border-color: var(--accent-primary);">
                        <h4 class="font-semibold mb-2 text-lg themed-text-accent">Step 1: Set Security Rules</h4>
                        <p class="text-sm themed-text-secondary mb-4">This is a one-time setup. Copy and paste these rules into your Firebase project. The app cannot read or write data without them.</p>
                        
                        <div class="mb-4">
                            <label class="block font-bold mb-1">Firestore Rules</label>
                            <a href="https://console.firebase.google.com/u/0/project/ai-podcasts-14de0/firestore" target="_blank" class="text-xs themed-text-secondary hover:underline">Go to Firestore Page (create database if needed, then click Rules tab) &rarr;</a>
                            <textarea id="firestoreRules" readonly class="w-full themed-input rounded-md p-3 h-28 mt-1 text-xs font-mono"></textarea>
                            <button type="button" data-copy-target="firestoreRules" class="copy-btn mt-2 w-full themed-button-secondary font-bold py-2 px-4 rounded-md text-sm">Copy Rules</button>
                        </div>

                        <div>
                            <label class="block font-bold mb-1">Storage Rules</label>
                            <a href="https://console.firebase.google.com/u/0/project/ai-podcasts-14de0/storage" target="_blank" class="text-xs themed-text-secondary hover:underline">Go to Storage Page (click 'Get started' if needed, then click Rules tab) &rarr;</a>
                            <textarea id="storageRules" readonly class="w-full themed-input rounded-md p-3 h-28 mt-1 text-xs font-mono"></textarea>
                             <button type="button" data-copy-target="storageRules" class="copy-btn mt-2 w-full themed-button-secondary font-bold py-2 px-4 rounded-md text-sm">Copy Rules</button>
                        </div>
                    </div>

                    <div class="lg:flex-1 mb-6">
                        <h4 class="font-semibold mb-2 text-lg themed-text-accent">Step 2: Enter Credentials</h4>
                        <p class="text-sm themed-text-secondary mb-4">Enter your keys below, or use the Import/Export feature to back them up.</p>
                        
                        <div id="importExportSection" class="mb-4">
                            <textarea id="importExportArea" class="w-full themed-input rounded-md p-3 h-24 text-xs" placeholder="Paste exported settings here to import..."></textarea>
                            <div class="flex gap-4 mt-2">
                                 <button type="button" id="importSettingsBtn" class="flex-1 themed-button-secondary font-bold py-2 px-4 rounded-md transition-colors">Import</button>
                                 <button type="button" id="exportSettingsBtn" class="flex-1 themed-button-secondary font-bold py-2 px-4 rounded-md transition-colors">Export</button>
                            </div>
                        </div>

                        <form id="firebaseConfigForm" class="space-y-2">
                            <input type="text" id="apiKey" placeholder="Firebase apiKey" class="w-full themed-input rounded-md p-3">
                            <input type="text" id="authDomain" placeholder="Firebase authDomain" class="w-full themed-input rounded-md p-3">
                            <input type="text" id="projectId" placeholder="Firebase projectId" class="w-full themed-input rounded-md p-3">
                            <input type="text" id="storageBucket" placeholder="Firebase storageBucket" class="w-full themed-input rounded-md p-3">
                            <input type="text" id="messagingSenderId" placeholder="Firebase messagingSenderId" class="w-full themed-input rounded-md p-3">
                            <input type="text" id="appId" placeholder="Firebase appId" class="w-full themed-input rounded-md p-3">
                            <div>
                               <input type="password" id="geminiApiKey" placeholder="Gemini API Key (Optional)" class="w-full themed-input rounded-md p-3">
                                <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-xs themed-text-secondary hover:underline ml-1">Get a Gemini API Key for AI features</a>
                            </div>

                            <div class="mt-4 p-3 rounded-md bg-orange-900 bg-opacity-50 border border-orange-500">
                                <p class="text-sm text-orange-200">
                                    <strong>Reminder:</strong> Anonymous sign-in must be enabled for the app to connect.
                                    <a href="https://console.firebase.google.com/u/0/project/ai-podcasts-14de0/authentication/providers" target="_blank" class="font-bold text-white hover:underline">Check it here.</a>
                                </p>
                            </div>
                            <div class="flex justify-end space-x-4 pt-4">
                                <button type="button" id="closeSettings" class="themed-button-secondary font-bold py-2 px-4 rounded-md transition-colors">Close</button>
                                <button type="submit" id="saveSettings" class="themed-button-primary font-bold py-2 px-4 rounded-md transition-colors">Save and Initialize</button>
                            </div>
                        </form>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp, deleteApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, addDoc, onSnapshot, updateDoc, deleteDoc, serverTimestamp, terminate, writeBatch, query, where, getDocs, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytesResumable, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        let app, auth, db, storage, userId, currentPlayingId = null, updateTimer = null;
        let podcastsData = {};
        let firebaseAppInitialized = false;
        let unsubscribeFromPodcasts = null;
        let unsubscribeFromFeeds = null;
        let currentConfig = {};
        let viewMode = 'list';

        const themeToggleButton = document.getElementById('themeToggleButton');
        const fileInput = document.getElementById('fileInput');
        const fileLabel = document.getElementById('fileLabel');
        const uploadSection = document.getElementById('uploadSection');
        const showUploadFormBtn = document.getElementById('showUploadFormBtn');
        const podcastListContainer = document.getElementById('podcastListContainer');
        const playedListContainer = document.getElementById('playedListContainer');
        const playedContainer = document.getElementById('playedContainer');
        const audioPlayer = document.getElementById('audioPlayer');
        const loadingMessage = document.getElementById('loadingMessage');
        const libraryTitle = document.getElementById('libraryTitle');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const deleteModal = document.getElementById('deleteModal');
        const settingsModal = document.getElementById('settingsModal');
        const settingsButton = document.getElementById('settingsButton');
        const speedControlButton = document.getElementById('speedControlButton');
        const shuffleButton = document.getElementById('shuffleButton');
        const repeatButton = document.getElementById('repeatButton');
        const closeSettings = document.getElementById('closeSettings');
        const firebaseConfigForm = document.getElementById('firebaseConfigForm');
        const viewToggleBtn = document.getElementById('viewToggleBtn');
        const iconGridView = document.getElementById('icon-grid-view');
        const iconListView = document.getElementById('icon-list-view');
        const urlInput = document.getElementById('urlInput');
        const importUrlBtn = document.getElementById('importUrlBtn');
        const rssInput = document.getElementById('rssInput');
        const addRssBtn = document.getElementById('addRssBtn');
        const libraryTab = document.getElementById('libraryTab');
        const rssEpisodesTab = document.getElementById('rssEpisodesTab');
        const manageFeedsTab = document.getElementById('manageFeedsTab');
        const libraryContent = document.getElementById('libraryContent');
        const rssEpisodesContent = document.getElementById('rssEpisodesContent');
        const manageFeedsContent = document.getElementById('manageFeedsContent');
        const manageFeedInput = document.getElementById('manageFeedInput');
        const manageFeedLimit = document.getElementById('manageFeedLimit');
        const addManageFeedBtn = document.getElementById('addManageFeedBtn');
        const refreshManageFeedsBtn = document.getElementById('refreshManageFeedsBtn');
        const fetchMoreModal = document.getElementById('fetchMoreModal');
        const fetchModalPodcastName = document.getElementById('fetchModalPodcastName');
        const fetchCount = document.getElementById('fetchCount');
        const fetchMoreConfirm = document.getElementById('fetchMoreConfirm');
        const fetchMoreCancel = document.getElementById('fetchMoreCancel');
        
        // Audio controls
        const audioControls = document.getElementById('audioControls');
        const nowPlayingBar = document.getElementById('nowPlayingBar');
        const nowPlayingArtwork = document.getElementById('nowPlayingArtwork');
        const nowPlayingTitle = document.getElementById('nowPlayingTitle');
        const nowPlayingTime = document.getElementById('nowPlayingTime');
        const volumeSlider = document.getElementById('volumeSlider');
        const mainPlayPauseBtn = document.getElementById('mainPlayPauseBtn');
        const mainPlayIcon = document.getElementById('mainPlayIcon');
        const mainPauseIcon = document.getElementById('mainPauseIcon');
        const rssFeedsContainer = document.getElementById('rssFeedsContainer');
        const rssFeedsList = document.getElementById('rssFeedsList');
        
        const importExportArea = document.getElementById('importExportArea');
        const importSettingsBtn = document.getElementById('importSettingsBtn');
        const exportSettingsBtn = document.getElementById('exportSettingsBtn');
        const configKeys = ['apiKey', 'authDomain', 'projectId', 'storageBucket', 'messagingSenderId', 'appId', 'geminiApiKey'];

        const playIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`;
        const pauseIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`;
        const replayIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12A8 8 0 1013.4 5.37" /></svg>`;
        const moveToLibraryIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" /></svg>`;
        const restartIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 19 2 12 11 5 11 19"></polygon><polygon points="22 19 13 12 22 5 22 19"></polygon></svg>`;
        
        const playbackSpeeds = [1, 1.25, 1.5, 2];
        let currentSpeedIndex = 0;
        let isShuffle = false;
        let isRepeat = false;

        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            const themeIconDark = document.getElementById('theme-icon-dark');
            const themeIconLight = document.getElementById('theme-icon-light');
            if (theme === 'light') {
                themeIconDark.classList.add('hidden');
                themeIconLight.classList.remove('hidden');
            } else {
                themeIconDark.classList.remove('hidden');
                themeIconLight.classList.add('hidden');
            }
            localStorage.setItem('theme', theme);
        }
        
        async function reinitializeFirebase(config) {
            if (app) {
                if (unsubscribeFromPodcasts) unsubscribeFromPodcasts();
                 if (unsubscribeFromFeeds) unsubscribeFromFeeds();
                if(db) await terminate(db).catch(e => console.error("DB termination error", e));
                await deleteApp(app).catch(e => console.error("App deletion error", e));
                firebaseAppInitialized = false;
                app = null;
            }
            initializeFirebase(config);
        }

        async function initializeFirebase(config) {
            if (firebaseAppInitialized) return;
            
            currentConfig = config;
            const firebaseKeys = configKeys.filter(k => k !== 'geminiApiKey');
            const missingKeys = firebaseKeys.filter(key => !config[key]);

            if (missingKeys.length > 0) {
                 loadingMessage.innerHTML = `Firebase config is incomplete. Missing: ${missingKeys.join(', ')}. <button id="openSettingsFromMsg" class="themed-text-accent underline">Update settings</button>.`;
                 document.getElementById('openSettingsFromMsg').addEventListener('click', () => settingsModal.classList.remove('hidden'));
                 firebaseAppInitialized = false;
                 return;
            }

            try {
                loadingMessage.textContent = 'Initializing Firebase...';
                const fbConfig = {...config};
                delete fbConfig.geminiApiKey;

                app = initializeApp(fbConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                storage = getStorage(app);
                firebaseAppInitialized = true;
                
                // Safely access DOM elements with null checks
                if (showUploadFormBtn) showUploadFormBtn.classList.remove('hidden');
                setupAuthListener();
                console.log('Firebase initialized successfully');
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                if (loadingMessage) {
                    loadingMessage.innerHTML = `Firebase init failed: ${error.message}. <button id="openSettingsFromMsg" class="themed-text-accent underline">Check credentials</button>.`;
                    const settingsBtn = document.getElementById('openSettingsFromMsg');
                    if (settingsBtn && settingsModal) {
                        settingsBtn.addEventListener('click', () => settingsModal.classList.remove('hidden'));
                    }
                }
                firebaseAppInitialized = false;
            }
        }

        function setupAuthListener() {
            console.log('Setting up auth listener...');
            onAuthStateChanged(auth, user => {
                if (user) {
                    console.log('User authenticated:', user.uid);
                    userId = user.uid;
                    loadPodcasts();
                    loadManageFeeds();
                } else {
                    console.log('No user, signing in anonymously...');
                    signInAnonymously(auth).catch(error => {
                        console.error("Anonymous sign-in failed:", error);
                        if (loadingMessage) {
                            loadingMessage.innerHTML = `Authentication failed. <button id="openSettingsFromMsg" class="themed-text-accent underline">Check your settings</button> and ensure Anonymous Sign-In is enabled in Firebase.`;
                            const settingsBtn = document.getElementById('openSettingsFromMsg');
                            if (settingsBtn && settingsModal) {
                                settingsBtn.addEventListener('click', () => settingsModal.classList.remove('hidden'));
                            }
                        }
                    });
                }
            });
        }
        
        function getConfigFromForm() {
            const config = {};
            configKeys.forEach(key => config[key] = document.getElementById(key).value.trim());
            return config;
        }

        function populateFormFromConfig(config) {
            configKeys.forEach(key => {
                const input = document.getElementById(key);
                if (input) input.value = config[key] || '';
            });
        }
        
        function setupSettingsModal() {
            document.getElementById('firestoreRules').value = `rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /podcasts-data/public/podcasts/{podcastId} {
      allow read: if true;
      allow write: if request.auth != null;
    }
    match /rss_feeds/{feedId} {
        allow read, write: if request.auth != null;
    }
  }
}`;
            document.getElementById('storageRules').value = `rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    match /podcasts/{allPaths=**} {
      allow read: if true;
      allow write: if request.auth != null;
    }
    match /artwork/{allPaths=**} {
      allow read: if true;
      allow write: if request.auth != null;
    }
  }
}`;
            document.querySelectorAll('.copy-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const targetId = e.currentTarget.dataset.copyTarget;
                    const textarea = document.getElementById(targetId);
                    textarea.select();
                    try {
                        document.execCommand('copy');
                        showNotification('Rules copied to clipboard!', 'success');
                    } catch (err) {
                        showNotification('Copy failed. Please copy manually.', 'error');
                    }
                });
            });

            const saveAndClose = () => {
                const configData = getConfigFromForm();
                localStorage.setItem('firebaseConfig', JSON.stringify(configData));
                showNotification('Configuration saved!', 'success');
                settingsModal.classList.add('hidden');
                reinitializeFirebase(configData);
            };

            firebaseConfigForm.addEventListener('submit', (e) => {
                e.preventDefault();
                saveAndClose();
            });
            
            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) {
                    saveAndClose();
                }
            });

            exportSettingsBtn.addEventListener('click', () => {
                const config = getConfigFromForm();
                importExportArea.value = btoa(JSON.stringify(config));
                importExportArea.select();
                showNotification('Export text created!', 'success');
            });
            
            importSettingsBtn.addEventListener('click', () => {
                if (!importExportArea.value.trim()) return showNotification('Import area is empty.', 'error');
                try {
                    populateFormFromConfig(JSON.parse(atob(importExportArea.value.trim())));
                    showNotification('Settings imported!', 'success');
                } catch(e) {
                    showNotification('Import failed. Invalid text.', 'error');
                }
            });

            settingsButton.addEventListener('click', () => {
                const storedConfig = JSON.parse(localStorage.getItem('firebaseConfig') || '{}');
                populateFormFromConfig(storedConfig);
                settingsModal.classList.remove('hidden');
            });
            closeSettings.addEventListener('click', () => settingsModal.classList.add('hidden'));
        }

        // Load personal library (uploaded files only, excluding RSS)
        function loadPodcasts() {
            if (!firebaseAppInitialized) return;
            if (unsubscribeFromPodcasts) unsubscribeFromPodcasts(); 
            
            const podcastsCol = collection(db, 'podcasts-data', 'public', 'podcasts');
            
            // First try to load all podcasts and filter client-side since your existing data might not have 'source' field
            unsubscribeFromPodcasts = onSnapshot(podcastsCol, snapshot => {
                let allPodcasts = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Filter out RSS episodes (only show files without source='rss' or no source field)
                let libraryPodcasts = allPodcasts.filter(p => !p.source || p.source !== 'rss');
                
                // Sort by upload date (newest first) - prioritize user uploads
                libraryPodcasts.sort((a, b) => {
                    // First, prioritize user uploads over RSS
                    if (a.source !== b.source) {
                        if (a.source === 'upload' && b.source !== 'upload') return -1;
                        if (a.source !== 'upload' && b.source === 'upload') return 1;
                    }
                    // Then sort by date (newest first)
                    const dateA = a.uploadedAt?.toDate?.() || new Date(0);
                    const dateB = b.uploadedAt?.toDate?.() || new Date(0);
                    return dateB - dateA; // Newest first
                });
                
                console.log('Total podcasts found:', allPodcasts.length);
                console.log('Library podcasts (non-RSS):', libraryPodcasts.length);
                
                const activePodcasts = libraryPodcasts.filter(p => !p.isPlayed);
                const playedPodcasts = libraryPodcasts.filter(p => p.isPlayed);

                podcastsData = Object.fromEntries(allPodcasts.map(p => [p.id, p]));
                
                if (libraryPodcasts.length === 0) {
                    loadingMessage.textContent = 'Your library is empty. Upload your first podcast!';
                    loadingMessage.style.display = 'block';
                } else {
                    loadingMessage.style.display = 'none';
                }
                
                renderPodcastList(activePodcasts, podcastListContainer, false);
                renderPodcastList(playedPodcasts, playedListContainer, true);

                playedContainer.classList.toggle('hidden', playedPodcasts.length === 0);

            }, error => {
                console.error("Error loading podcasts: ", error);
                if (loadingMessage) {
                    loadingMessage.innerHTML = `Error loading library. <button id="openSettingsFromMsg" class="themed-text-accent underline">Check Firestore Rules</button> in settings.`;
                    const settingsBtn = document.getElementById('openSettingsFromMsg');
                    if (settingsBtn && settingsModal) {
                        settingsBtn.addEventListener('click', () => settingsModal.classList.remove('hidden'));
                    }
                }
            });
        }

        // Load RSS episodes separately
        function loadRssEpisodes() {
            if (!firebaseAppInitialized) return;
            
            const podcastsCol = collection(db, 'podcasts-data', 'public', 'podcasts');
            const q = query(podcastsCol, where('source', '==', 'rss'));
            
            onSnapshot(q, snapshot => {
                const rssEpisodesData = {};
                snapshot.forEach(doc => {
                    rssEpisodesData[doc.id] = { id: doc.id, ...doc.data() };
                });
                
                let activeRssEpisodes = Object.values(rssEpisodesData).filter(p => !p.isPlayed);
                let playedRssEpisodes = Object.values(rssEpisodesData).filter(p => p.isPlayed);
                
                // Sort by upload date (newest first)
                activeRssEpisodes.sort((a, b) => {
                    const dateA = a.uploadedAt?.toDate?.() || new Date(0);
                    const dateB = b.uploadedAt?.toDate?.() || new Date(0);
                    return dateB - dateA; // Newest first
                });
                
                playedRssEpisodes.sort((a, b) => {
                    const dateA = a.uploadedAt?.toDate?.() || new Date(0);
                    const dateB = b.uploadedAt?.toDate?.() || new Date(0);
                    return dateB - dateA; // Newest first
                });
                
                const rssEpisodesContainer = document.getElementById('rssEpisodesContainer');
                
                if (activeRssEpisodes.length === 0 && playedRssEpisodes.length === 0) {
                    rssEpisodesContainer.innerHTML = '<p class="themed-text-secondary text-center py-4">No RSS episodes imported yet.</p>';
                    return;
                }
                
                // Clear container
                rssEpisodesContainer.innerHTML = '';
                
                // Create active episodes container
                if (activeRssEpisodes.length > 0) {
                    const activeContainer = document.createElement('div');
                    activeContainer.className = viewMode === 'grid' ? 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4' : 'space-y-4';
                    renderPodcastList(activeRssEpisodes, activeContainer, false);
                    rssEpisodesContainer.appendChild(activeContainer);
                }
                
                // Add played RSS episodes if any
                if (playedRssEpisodes.length > 0) {
                    const playedSection = document.createElement('div');
                    playedSection.className = 'mt-8';
                    playedSection.innerHTML = '<h3 class="text-xl font-semibold mb-4">Played RSS Episodes</h3>';
                    
                    const playedContainer = document.createElement('div');
                    playedContainer.className = viewMode === 'grid' ? 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4' : 'space-y-4';
                    renderPodcastList(playedRssEpisodes, playedContainer, true);
                    playedSection.appendChild(playedContainer);
                    rssEpisodesContainer.appendChild(playedSection);
                }
                
            }, error => {
                console.error("Error loading RSS episodes: ", error);
                const rssEpisodesContainer = document.getElementById('rssEpisodesContainer');
                rssEpisodesContainer.innerHTML = '<p class="themed-text-secondary text-center py-4">Error loading RSS episodes.</p>';
            });
        }
        
        async function getIntelligentName(originalName) {
            const apiKey = currentConfig.geminiApiKey;
            if(!apiKey) return originalName;

            const prompt = `Analyze the filename "${originalName}" and create a short, professional title. Focus on the main subject. For example, 'podcast_business_episode_12' should become 'Business Podcast Ep. 12'. 'tech_news_weekly_2025_06_21' should become 'Tech News Weekly (6/21/2025)'. 'ambient_study_music' should become 'Ambient Study Music'. Return ONLY the new title.`;
            
            try {
                let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = { contents: chatHistory };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API responded with ${response.status}`);
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text.trim().replace(/\"/g, "");
                } else {
                    throw new Error("Invalid response structure from Gemini API");
                }
            } catch (error) {
                console.error("Gemini API call failed:", error);
                showNotification("AI Naming Failed. Using original filename.", "error");
                return originalName;
            }
        }

        async function generateArtwork(title) {
             const apiKey = currentConfig.geminiApiKey;
             if(!apiKey) return null;

             const prompt = `Generate a square 1:1 aspect ratio abstract cover art inspired by "${title}". Use vibrant colors and modern graphic design. Theme colors based on title words: tech/news = blues and oranges, music = purples and golds, nature = greens and blues. Create flowing geometric shapes, gradients, and abstract patterns. ABSOLUTELY CRITICAL: This must be a completely blank visual design with ZERO text, letters, words, numbers, or any written content. No typography whatsoever. Pure abstract visual art only. Square format required.`;
             try {
                const payload = { 
                    instances: [{ prompt }], 
                    parameters: { 
                        "sampleCount": 1,
                        "aspectRatio": "1:1"
                    } 
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                 if (!response.ok) throw new Error(`API responded with ${response.status}`);
                const result = await response.json();
                if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                    return `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                }
            } catch (error) {
                console.error("Imagen API call failed:", error);
                showNotification("AI Artwork Generation Failed.", "error");
            }
            return null;
        }
        
        async function uploadArtwork(base64Data, fileName) {
            try {
                const res = await fetch(base64Data);
                const blob = await res.blob();
                const storagePath = `artwork/${fileName}`;
                const artworkRef = ref(storage, storagePath);
                await uploadBytesResumable(artworkRef, blob);
                return await getDownloadURL(artworkRef);
            } catch(error) {
                console.error("Artwork upload failed:", error);
                showNotification("Artwork upload failed.", "error");
                return null;
            }
        }

        function getMetadata(file) {
            return new Promise(resolve => {
                window.jsmediatags.read(file, {
                    onSuccess: (tag) => {
                        let artworkUrl = null;
                        if (tag.tags.picture) {
                            const { data, format } = tag.tags.picture;
                            let base64String = "";
                            for (let i = 0; i < data.length; i++) {
                                base64String += String.fromCharCode(data[i]);
                            }
                            artworkUrl = `data:${format};base64,${window.btoa(base64String)}`;
                        }
                        resolve({
                            artworkUrl: artworkUrl,
                            description: tag.tags.comment?.text || tag.tags.lyrics?.text || null
                        });
                    },
                    onError: (error) => {
                        console.warn('Could not read metadata:', error);
                        resolve({ artworkUrl: null, description: null });
                    }
                });
            });
        }


        async function handleFileUpload(file, fileNameOverride = null) {
            if (!file || !userId) {
                console.log('Upload blocked: file or userId missing', { file: !!file, userId: !!userId });
                return;
            }

            try {
                const fileLabel = document.getElementById('fileLabel');
                if (fileLabel) {
                    fileLabel.textContent = "Analyzing...";
                    fileLabel.classList.add('cursor-not-allowed', 'opacity-50');
                }
                fileInput.disabled = true;

                const [intelligentName, metadata] = await Promise.all([
                    getIntelligentName(fileNameOverride || file.name),
                    getMetadata(file)
                ]);
                
                let finalArtworkUrl = metadata.artworkUrl;
                if (finalArtworkUrl) {
                    if (fileLabel) fileLabel.textContent = "Uploading Artwork...";
                    finalArtworkUrl = await uploadArtwork(finalArtworkUrl, `artwork_${Date.now()}.png`);
                } else if (currentConfig.geminiApiKey) {
                    if (fileLabel) fileLabel.textContent = "Creating Artwork...";
                    const generatedArtBase64 = await generateArtwork(intelligentName);
                    if(generatedArtBase64) {
                        if (fileLabel) fileLabel.textContent = "Uploading Artwork...";
                        finalArtworkUrl = await uploadArtwork(generatedArtBase64, `artwork_${Date.now()}.png`);
                    }
                }

                if (fileLabel) fileLabel.textContent = "Uploading Audio...";

                const progressContainer = document.getElementById('uploadProgressContainer');
                const progressBar = document.getElementById('uploadProgressBar');
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';

                const storagePath = `podcasts/${Date.now()}-${file.name}`;
                const uploadTask = uploadBytesResumable(ref(storage, storagePath), file);

                uploadTask.on('state_changed', 
                    snapshot => {
                        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                        progressBar.style.width = `${progress}%`;
                        if (fileLabel) fileLabel.textContent = `Uploading... ${Math.round(progress)}%`;
                    },
                    error => { 
                        console.error("Upload failed:", error);
                        showNotification(`Upload failed: ${error.code}. Check Storage Rules.`, "error"); 
                        resetUploadUI(); 
                    }, 
                    async () => {
                        try {
                            const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
                            if (fileLabel) fileLabel.textContent = "Finalizing...";
                            
                            const tempAudio = document.createElement('audio');
                            tempAudio.src = URL.createObjectURL(file);
                            tempAudio.onloadedmetadata = async () => {
                                await addDoc(collection(db, 'podcasts-data', 'public', 'podcasts'), { 
                                    name: intelligentName, 
                                    url: downloadURL, 
                                    storagePath, 
                                    playbackPosition: 0, 
                                    duration: tempAudio.duration, 
                                    uploadedAt: serverTimestamp(), 
                                    uploader: userId,
                                    artworkUrl: finalArtworkUrl,
                                    description: metadata.description,
                                    isPlayed: false,
                                    source: 'upload'
                                });
                                showNotification("Upload successful!", "success");
                                resetUploadUI();
                            };
                        } catch (error) {
                            console.error('Error completing upload:', error);
                            showNotification('Upload failed: ' + error.message, 'error');
                            resetUploadUI();
                        }
                    }
                );
            } catch (error) {
                console.error('Upload error:', error);
                showNotification('Upload failed: ' + error.message, 'error');
                resetUploadUI();
            }
        }
        
        async function loadInitialConfig() {
            if (loadingMessage) loadingMessage.textContent = 'Loading configuration...';
            let firebaseConfig;

            try {
                const response = await fetch('firebase-config.json');
                if (response.ok) {
                    firebaseConfig = await response.json();
                    console.log('Loaded Firebase config from file');
                } else {
                    console.log('Could not load firebase-config.json, status:', response.status);
                }
            } catch (error) {
                console.log('firebase-config.json not found, checking local storage.');
            }

            if (!firebaseConfig) {
                const storedConfig = localStorage.getItem('firebaseConfig');
                if (storedConfig) {
                    try {
                        firebaseConfig = JSON.parse(storedConfig);
                        console.log('Loaded Firebase config from localStorage');
                    } catch (e) { console.error("Could not parse stored config", e); }
                }
            }

            if (firebaseConfig && Object.values(firebaseConfig).some(v => v)) {
                console.log('Initializing Firebase with config...');
                await initializeFirebase(firebaseConfig);
            } else {
                console.log('No Firebase config found');
                if (loadingMessage) {
                    loadingMessage.innerHTML = 'Firebase is not configured. Please provide credentials in <button id="openSettingsFromMsg" class="themed-text-accent underline">settings</button>.';
                    const settingsBtn = document.getElementById('openSettingsFromMsg');
                    if (settingsBtn && settingsModal) {
                        settingsBtn.addEventListener('click', () => settingsModal.classList.remove('hidden'));
                    }
                }
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            applyTheme(savedTheme);
            themeToggleButton.addEventListener('click', () => {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                applyTheme(currentTheme === 'dark' ? 'light' : 'dark');
            });
            showUploadFormBtn.addEventListener('click', () => {
                uploadSection.classList.toggle('hidden');
                showUploadFormBtn.textContent = uploadSection.classList.contains('hidden') ? 'Add New Podcast' : 'Close Upload Form';
            });
            fileInput.addEventListener('change', (e) => {
                console.log('File input changed:', e.target.files);
                if(e.target.files && e.target.files.length > 0) {
                    const file = e.target.files[0];
                    console.log('Selected file:', file.name, file.type, file.size);
                    if (file.type.startsWith('audio/')) {
                        handleFileUpload(file);
                    } else {
                        showNotification('Please select an audio file', 'error');
                        fileInput.value = '';
                    }
                } else {
                    console.log('No files selected');
                }
            });
            importUrlBtn.addEventListener('click', async () => {
                 const url = urlInput.value.trim();
                 if(!url) return showNotification("Please enter a URL", "error");
                 
                 try {
                    const response = await fetch(url);
                    if(!response.ok) throw new Error(`Failed to fetch: ${response.statusText}`);
                    const blob = await response.blob();
                    const fileName = url.substring(url.lastIndexOf('/') + 1);
                    const file = new File([blob], fileName, {type: blob.type});
                    handleFileUpload(file, fileName);
                    urlInput.value = '';
                 } catch(e) {
                     console.error("URL Import failed:", e);
                     showNotification("Failed to import from URL. Check CORS policy.", "error");
                 }
            });
            addRssBtn.addEventListener('click', async () => {
                const url = rssInput.value.trim();
                const limit = parseInt(rssLimit.value) || 5;
                
                if(!url) return showNotification("Please enter a feed URL", "error");

                // Show loading state
                addRssBtn.disabled = true;
                addRssBtn.textContent = 'Importing...';

                try {
                    // Parse RSS feed and import episodes directly
                    const feedData = await parseRSSFeed(url, limit);
                    const { episodes, podcastTitle, podcastArtwork } = feedData;
                    
                    if (episodes.length === 0) {
                        showNotification('No audio episodes found in this RSS feed', 'error');
                        return;
                    }

                    // Add episodes to Firebase if available, otherwise show error
                    if (typeof db !== 'undefined' && db) {
                        // Save the RSS feed URL for tracking with podcast title
                        await addDoc(collection(db, 'rss_feeds'), { 
                            url: url, 
                            title: podcastTitle,
                            artwork: podcastArtwork,
                            addedAt: serverTimestamp() 
                        });

                        // Add episodes to podcasts collection
                        for (const episode of episodes) {
                            await addDoc(collection(db, 'podcasts-data', 'public', 'podcasts'), {
                                name: episode.title,
                                description: episode.description,
                                url: episode.url,
                                artworkUrl: episode.artworkUrl,
                                podcastTitle: episode.podcastTitle,
                                uploadedAt: serverTimestamp(),
                                playbackPosition: 0,
                                duration: 0,
                                isPlayed: false,
                                source: 'rss'
                            });
                        }
                        
                        // Reload RSS feeds list and RSS episodes
                        loadManageFeeds();
                        loadRssEpisodes();
                        
                        showNotification(`Successfully imported ${episodes.length} episodes from ${podcastTitle}!`, 'success');
                    } else {
                        showNotification('Firebase not configured. Please set up Firebase to import RSS feeds.', 'error');
                    }

                    rssInput.value = '';

                } catch (error) {
                    console.error('RSS import failed:', error);
                    showNotification(`RSS import failed: ${error.message}`, 'error');
                } finally {
                    // Reset button state
                    addRssBtn.disabled = false;
                    addRssBtn.textContent = 'Import';
                }
            });

            // RSS Feed management functionality
            addManageFeedBtn.addEventListener('click', async () => {
                const url = manageFeedInput.value.trim();
                const limit = parseInt(manageFeedLimit.value) || 5;
                
                if (!url) {
                    showNotification('Please enter a feed URL', 'error');
                    return;
                }

                addManageFeedBtn.disabled = true;
                addManageFeedBtn.textContent = 'Importing...';

                try {
                    const feedData = await parseRSSFeed(url, limit);
                    const { episodes, podcastTitle, podcastArtwork } = feedData;
                    
                    if (episodes.length === 0) {
                        showNotification('No audio episodes found in this RSS feed', 'error');
                        return;
                    }

                    if (typeof db !== 'undefined' && db) {
                        await addDoc(collection(db, 'rss_feeds'), { 
                            url: url, 
                            title: podcastTitle,
                            artwork: podcastArtwork,
                            addedAt: serverTimestamp() 
                        });

                        for (const episode of episodes) {
                            await addDoc(collection(db, 'podcasts-data', 'public', 'podcasts'), {
                                name: episode.title,
                                description: episode.description,
                                url: episode.url,
                                artworkUrl: episode.artworkUrl,
                                podcastTitle: episode.podcastTitle,
                                uploadedAt: serverTimestamp(),
                                playbackPosition: 0,
                                duration: 0,
                                isPlayed: false,
                                source: 'rss'
                            });
                        }
                        
                        loadManageFeeds();
                        loadRssEpisodes();
                        
                        showNotification(`Successfully imported ${episodes.length} episodes from ${podcastTitle}!`, 'success');
                    } else {
                        showNotification('Firebase not configured. Please set up Firebase to import RSS feeds.', 'error');
                    }

                    manageFeedInput.value = '';

                } catch (error) {
                    console.error('RSS import failed:', error);
                    showNotification(`RSS import failed: ${error.message}`, 'error');
                } finally {
                    addManageFeedBtn.disabled = false;
                    addManageFeedBtn.textContent = 'Import';
                }
            });

            // Refresh all feeds functionality
            refreshManageFeedsBtn.addEventListener('click', async () => {
                refreshManageFeedsBtn.disabled = true;
                refreshManageFeedsBtn.textContent = 'Refreshing...';
                
                try {
                    await refreshAllFeeds();
                    showNotification('Feeds refreshed successfully!', 'success');
                } catch (error) {
                    console.error('Refresh failed:', error);
                    showNotification('Failed to refresh feeds', 'error');
                } finally {
                    refreshManageFeedsBtn.disabled = false;
                    refreshManageFeedsBtn.textContent = 'Refresh All';
                }
            });

            speedControlButton.addEventListener('click', () => {
                currentSpeedIndex = (currentSpeedIndex + 1) % playbackSpeeds.length;
                const newSpeed = playbackSpeeds[currentSpeedIndex];
                audioPlayer.playbackRate = newSpeed;
                speedControlButton.textContent = `${newSpeed}x`;
                localStorage.setItem('playbackSpeed', newSpeed);
            });

            const savedSpeed = parseFloat(localStorage.getItem('playbackSpeed')) || 1;
            const savedSpeedIndex = playbackSpeeds.indexOf(savedSpeed);
            currentSpeedIndex = savedSpeedIndex !== -1 ? savedSpeedIndex : 0;
            audioPlayer.playbackRate = playbackSpeeds[currentSpeedIndex];
            speedControlButton.textContent = `${playbackSpeeds[currentSpeedIndex]}x`;

            const updatePlaybackModeUI = () => {
                shuffleButton.classList.toggle('control-active', isShuffle);
                repeatButton.classList.toggle('control-active', isRepeat);
            };

            isShuffle = localStorage.getItem('isShuffle') === 'true';
            isRepeat = localStorage.getItem('isRepeat') === 'true';
            updatePlaybackModeUI();

            shuffleButton.addEventListener('click', () => {
                isShuffle = !isShuffle;
                if(isShuffle) isRepeat = false;
                localStorage.setItem('isShuffle', isShuffle);
                localStorage.setItem('isRepeat', isRepeat);
                updatePlaybackModeUI();
            });

            repeatButton.addEventListener('click', () => {
                isRepeat = !isRepeat;
                if(isRepeat) isShuffle = false;
                localStorage.setItem('isRepeat', isRepeat);
                localStorage.setItem('isShuffle', isShuffle);
                updatePlaybackModeUI();
            });

            // Skip buttons - only add listeners if buttons exist
            const skipBackBtn = document.getElementById('skipBackBtn');
            const skipForwardBtn = document.getElementById('skipForwardBtn');

            if (skipBackBtn) {
                skipBackBtn.addEventListener('click', () => {
                    if (currentPlayingId && audioPlayer.src) {
                        const newTime = Math.max(0, audioPlayer.currentTime - 30);
                        audioPlayer.currentTime = newTime;
                        if (podcastsData[currentPlayingId]) {
                            podcastsData[currentPlayingId].playbackPosition = newTime;
                            updateSinglePodcastUI(currentPlayingId);
                            updatePlaybackPosition(currentPlayingId, newTime);
                        }
                    }
                });
            }

            if (skipForwardBtn) {
                skipForwardBtn.addEventListener('click', () => {
                    if (currentPlayingId && audioPlayer.src && podcastsData[currentPlayingId]) {
                        const podcast = podcastsData[currentPlayingId];
                        const newTime = Math.min(podcast.duration || audioPlayer.duration, audioPlayer.currentTime + 30);
                        audioPlayer.currentTime = newTime;
                        podcast.playbackPosition = newTime;
                        updateSinglePodcastUI(currentPlayingId);
                        updatePlaybackPosition(currentPlayingId, newTime);
                    }
                });
            }

            const savedView = localStorage.getItem('viewMode') || 'list';
            setViewMode(savedView);
            viewToggleBtn.addEventListener('click', () => {
                const newMode = viewMode === 'list' ? 'grid' : 'list';
                setViewMode(newMode);
            });

            // Tab functionality
            function switchTab(activeTab, activeContent) {
                // Reset all tabs
                [libraryTab, rssEpisodesTab, manageFeedsTab].forEach(tab => {
                    tab.classList.add('themed-text-secondary');
                    tab.classList.remove('themed-text-accent', 'border-b-2', 'border-orange-500');
                });
                
                // Hide all content
                [libraryContent, rssEpisodesContent, manageFeedsContent].forEach(content => {
                    content.classList.add('hidden');
                });
                
                // Activate selected tab and content
                activeTab.classList.add('themed-text-accent', 'border-b-2', 'border-orange-500');
                activeTab.classList.remove('themed-text-secondary');
                activeContent.classList.remove('hidden');
            }

            libraryTab.addEventListener('click', () => {
                switchTab(libraryTab, libraryContent);
            });

            rssEpisodesTab.addEventListener('click', () => {
                switchTab(rssEpisodesTab, rssEpisodesContent);
                loadRssEpisodes();
            });

            manageFeedsTab.addEventListener('click', () => {
                switchTab(manageFeedsTab, manageFeedsContent);
                loadManageFeeds();
            });

            // Fetch more episodes modal handlers
            fetchMoreCancel.addEventListener('click', () => {
                fetchMoreModal.classList.add('hidden');
            });

            fetchMoreConfirm.addEventListener('click', async () => {
                const feedId = fetchMoreModal.dataset.feedId;
                const feedUrl = fetchMoreModal.dataset.feedUrl;
                const feedTitle = fetchMoreModal.dataset.feedTitle;
                const count = parseInt(fetchCount.value);
                
                fetchMoreModal.classList.add('hidden');
                
                fetchMoreConfirm.disabled = true;
                fetchMoreConfirm.textContent = 'Fetching...';
                
                try {
                    await fetchOlderEpisodes(feedId, feedUrl, feedTitle, count);
                } finally {
                    fetchMoreConfirm.disabled = false;
                    fetchMoreConfirm.textContent = 'Fetch Episodes';
                }
            });

            // Close modal when clicking outside
            fetchMoreModal.addEventListener('click', (e) => {
                if (e.target === fetchMoreModal) {
                    fetchMoreModal.classList.add('hidden');
                }
            });

            // Edit feed modal elements
            const editFeedModal = document.getElementById('editFeedModal');
            const editFeedName = document.getElementById('editFeedName');
            const editFeedUrl = document.getElementById('editFeedUrl');
            const editFeedSave = document.getElementById('editFeedSave');
            const editFeedCancel = document.getElementById('editFeedCancel');

            // Edit feed modal handlers
            editFeedCancel.addEventListener('click', () => {
                editFeedModal.classList.add('hidden');
            });

            editFeedSave.addEventListener('click', async () => {
                const feedId = editFeedModal.dataset.feedId;
                const newName = editFeedName.value.trim();
                const newUrl = editFeedUrl.value.trim();
                
                if (!newName || !newUrl) {
                    showNotification('Please fill in both name and URL', 'error');
                    return;
                }
                
                editFeedModal.classList.add('hidden');
                editFeedSave.disabled = true;
                editFeedSave.textContent = 'Saving...';
                
                try {
                    await updateDoc(doc(db, 'rss_feeds', feedId), {
                        title: newName,
                        url: newUrl,
                        lastChecked: serverTimestamp()
                    });
                    
                    showNotification('Feed updated successfully', 'success');
                    loadManageFeeds();
                } catch (error) {
                    console.error('Error updating feed:', error);
                    showNotification(`Failed to update feed: ${error.message}`, 'error');
                } finally {
                    editFeedSave.disabled = false;
                    editFeedSave.textContent = 'Save Changes';
                }
            });

            // Close edit modal when clicking outside
            editFeedModal.addEventListener('click', (e) => {
                if (e.target === editFeedModal) {
                    editFeedModal.classList.add('hidden');
                }
            });

            // Volume control initialization and event handlers
            const volumeSlider = document.getElementById('volumeSlider');
            if (volumeSlider) {
                // Restore saved volume or set default
                const savedVolume = localStorage.getItem('audioVolume') || '100';
                volumeSlider.value = savedVolume;
                audioPlayer.volume = savedVolume / 100;
                
                // Handle volume changes
                volumeSlider.addEventListener('input', (e) => {
                    const volume = e.target.value / 100;
                    audioPlayer.volume = volume;
                    localStorage.setItem('audioVolume', e.target.value);
                    console.log('Volume changed to:', volume);
                });
            }

            // Main play/pause button
            const mainPlayPauseBtn = document.getElementById('mainPlayPauseBtn');
            if (mainPlayPauseBtn) {
                mainPlayPauseBtn.addEventListener('click', () => {
                    if (currentPlayingId && audioPlayer.src) {
                        if (audioPlayer.paused) {
                            audioPlayer.play();
                        } else {
                            audioPlayer.pause();
                        }
                    }
                });
            }

            setupSettingsModal();
            loadInitialConfig();
        });
        
        function setViewMode(mode) {
             viewMode = mode;
             localStorage.setItem('viewMode', mode);
             if (mode === 'grid') {
                 iconGridView.classList.add('hidden');
                 iconListView.classList.remove('hidden');
                 podcastListContainer.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4';
                 playedListContainer.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4';
             } else {
                 iconGridView.classList.remove('hidden');
                 iconListView.classList.add('hidden');
                 podcastListContainer.className = 'space-y-4';
                 playedListContainer.className = 'space-y-4';
             }
             loadPodcasts();
        }

        function renderPodcastList(podcasts, listElement, isPlayedList) {
            listElement.innerHTML = '';
            if (podcasts.length === 0 && isPlayedList) {
                 return;
            }
            if (podcasts.length === 0 && !isPlayedList) {
                listElement.innerHTML = `<p class="themed-text-secondary text-center py-4">Your library is empty. Upload your first podcast!</p>`;
                loadingMessage.style.display = 'none';
                return;
            }
            
            loadingMessage.style.display = 'none';

            podcasts.forEach(podcast => {
                const isPlaying = podcast.id === currentPlayingId && !audioPlayer.paused;
                const progressPercent = (podcast.duration > 0) ? (podcast.playbackPosition / podcast.duration) * 100 : 0;
                const defaultArtwork = `https://placehold.co/120x120/374151/9ca3af?text=🎵`;
                const podcastElement = document.createElement('div');
                podcastElement.dataset.id = podcast.id;
                
                if (viewMode === 'grid') {
                    podcastElement.className = 'podcast-item themed rounded-xl shadow-lg transition-all duration-300 overflow-hidden hover:shadow-xl transform hover:scale-102';
                    podcastElement.innerHTML = `
                        <div class="relative">
                            <img src="${podcast.artworkUrl || defaultArtwork}" class="w-full aspect-square object-cover" onerror="this.src='${defaultArtwork}'">
                            <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent"></div>
                            <div class="absolute bottom-3 left-3 right-3">
                                <div class="flex items-center justify-between mb-2">
                                    <button data-id="${podcast.id}" class="restart-btn bg-white/20 backdrop-blur-sm rounded-full p-2 hover:bg-white/30 transition-all">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                        </svg>
                                    </button>
                                    <button data-id="${podcast.id}" class="play-pause-btn bg-orange-500 hover:bg-orange-600 rounded-full p-2 transition-all transform hover:scale-105 shadow-lg">
                                        ${isPlaying ? 
                                            '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' :
                                            '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white ml-0.5" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>'
                                        }
                                    </button>
                                    <button data-id="${podcast.id}" data-storage-path="${podcast.storagePath}" class="delete-btn bg-white/20 backdrop-blur-sm rounded-full p-2 hover:bg-red-500/80 transition-all">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                        </svg>
                                    </button>
                                </div>
                                <div data-id="${podcast.id}" class="progress-bar-wrapper w-full rounded-full h-1 cursor-pointer relative bg-white/20">
                                    <div class="progress-bar h-full rounded-full pointer-events-none bg-orange-500" style="width: ${progressPercent}%;"></div>
                                    <div class="scrubber-handle opacity-0" style="left: ${progressPercent}%"></div>
                                </div>
                            </div>
                        </div>
                        <div class="p-4">
                            <h3 class="font-semibold text-lg mb-1 line-clamp-2">${podcast.name}</h3>
                            <p class="text-sm themed-text-secondary mb-2">${formatTime(podcast.playbackPosition)} / ${formatTime(podcast.duration)}</p>
                            ${podcast.description ? `<p class="text-xs themed-text-secondary line-clamp-2">${podcast.description}</p>` : ''}
                        </div>
                    `;

                } else {
                    // Mobile-optimized list view
                    podcastElement.className = 'podcast-item themed rounded-xl p-4 sm:p-6 mb-4 shadow-lg transition-all duration-300 hover:shadow-xl';
                    podcastElement.innerHTML = `
                        <div class="flex flex-col sm:flex-row sm:items-start space-y-4 sm:space-y-0 sm:space-x-6">
                            <!-- Large Artwork -->
                            <div class="flex-shrink-0 self-center sm:self-start">
                                <img src="${podcast.artworkUrl || defaultArtwork}" class="w-24 h-24 sm:w-32 sm:h-32 object-cover rounded-xl shadow-md" onerror="this.src='${defaultArtwork}'">
                            </div>
                            
                            <!-- Content -->
                            <div class="flex-grow min-w-0">
                                <div class="mb-3">
                                    <h3 class="font-bold text-lg sm:text-xl mb-2 line-clamp-2 themed-text-primary">${podcast.name}</h3>
                                    ${podcast.description ? `<p class="text-sm themed-text-secondary line-clamp-2 sm:line-clamp-3 mb-3">${podcast.description}</p>` : ''}
                                    <div class="flex flex-wrap items-center gap-2 text-sm themed-text-secondary mb-3">
                                        <span>${formatTime(podcast.playbackPosition)} / ${formatTime(podcast.duration)}</span>
                                        ${podcast.podcastTitle ? `<span>•</span><span class="truncate">${podcast.podcastTitle}</span>` : ''}
                                    </div>
                                </div>
                                
                                <!-- Action Buttons - Mobile Optimized -->
                                <div class="flex items-center justify-center sm:justify-end space-x-2 sm:space-x-3 mb-4">
                                    <button data-id="${podcast.id}" class="restart-btn themed-button-secondary rounded-full sm:rounded-xl p-2 sm:p-3 hover:scale-105 transition-all shadow-md">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                        </svg>
                                    </button>
                                    <button data-id="${podcast.id}" class="play-pause-btn bg-orange-500 hover:bg-orange-600 rounded-full sm:rounded-xl p-2 sm:p-3 transition-all transform hover:scale-105 shadow-lg">
                                        ${isPlaying ? 
                                            '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' :
                                            '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5 text-white" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>'
                                        }
                                    </button>
                                    ${isPlayedList ? `<button data-id="${podcast.id}" class="move-to-library-btn themed-button-secondary rounded-full sm:rounded-xl p-2 sm:p-3 hover:scale-105 transition-all shadow-md hover:bg-green-500">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2H5a2 2 0 00-2-2z" />
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5a2 2 0 012-2h2a2 2 0 012 2v0M9 12l2 2 4-4" />
                                        </svg>
                                    </button>` : ''}
                                    <button data-id="${podcast.id}" data-storage-path="${podcast.storagePath}" class="delete-btn themed-button-danger rounded-full sm:rounded-xl p-2 sm:p-3 hover:scale-105 transition-all shadow-md">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                        </svg>
                                    </button>
                                </div>
                                
                                <!-- Progress Bar -->
                                <div data-id="${podcast.id}" class="progress-bar-wrapper w-full rounded-full h-2 cursor-pointer relative bg-gray-200 dark:bg-gray-700">
                                    <div class="progress-bar h-full rounded-full pointer-events-none bg-orange-500" style="width: ${progressPercent}%;"></div>
                                    <div class="scrubber-handle opacity-0" style="left: ${progressPercent}%"></div>
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                listElement.appendChild(podcastElement);
            });
        }
        
        function updateSinglePodcastUI(id) {
            const podcast = podcastsData[id];
            if (!id || !podcast) return;
            const elements = document.querySelectorAll(`[data-id="${id}"]`);
            if (elements.length === 0) return;

            elements.forEach(element => {
                const isPlaying = id === currentPlayingId && !audioPlayer.paused;
                const isPlayed = podcast.isPlayed;
                const progressPercent = (podcast.duration > 0) ? (podcast.playbackPosition / podcast.duration) * 100 : 0;
                
                const playButton = element.querySelector('.play-pause-btn');
                if(playButton) {
                    const playButtonIcon = isPlayed ? replayIconSVG : (isPlaying ? pauseIconSVG : playIconSVG);
                    playButton.innerHTML = playButtonIcon;
                }
                
                const timeLabel = element.querySelector('.text-sm');
                if(timeLabel) timeLabel.textContent = `${formatTime(podcast.playbackPosition)} / ${formatTime(podcast.duration)}`;

                const progressBar = element.querySelector('.progress-bar');
                if(progressBar) progressBar.style.width = `${progressPercent}%`;

                const scrubberHandle = element.querySelector('.scrubber-handle');
                if(scrubberHandle) scrubberHandle.style.left = `${progressPercent}%`;
            });
        }

        // Load RSS feeds for management tab
        async function loadManageFeeds() {
            try {
                const rssCol = collection(db, 'rss_feeds');
                const rssSnapshot = await getDocs(rssCol);
                
                const manageFeedsList = document.getElementById('manageFeedsList');
                
                if (rssSnapshot.empty) {
                    manageFeedsList.innerHTML = '<p class="themed-text-secondary text-center py-4">No RSS feeds added yet.</p>';
                    return;
                }
                
                manageFeedsList.innerHTML = '';
                
                rssSnapshot.forEach(doc => {
                    const feed = doc.data();
                    const feedElement = document.createElement('div');
                    feedElement.className = 'themed rounded-lg p-4 flex justify-between items-center';
                    const lastChecked = feed.lastChecked ? new Date(feed.lastChecked.toDate()).toLocaleDateString() : 'Never';
                    const feedTitle = feed.title || feed.url;
                    
                    feedElement.innerHTML = `
                        <div class="flex items-center space-x-4 flex-grow min-w-0 mr-4">
                            ${feed.artwork ? `<img src="${feed.artwork}" alt="Podcast artwork" class="w-12 h-12 rounded-md object-cover flex-shrink-0">` : ''}
                            <div class="min-w-0 flex-grow">
                                <div class="themed-text-primary font-medium truncate" title="${feedTitle}">${feedTitle}</div>
                                <div class="text-xs themed-text-secondary">Last checked: ${lastChecked}</div>
                                <div class="text-xs themed-text-secondary truncate" title="${feed.url}">${feed.url}</div>
                            </div>
                        </div>
                        <div class="flex space-x-2 flex-shrink-0">
                            <button onclick="showFetchMoreModal('${doc.id}', '${feedTitle}', '${feed.url}')" class="themed-button-primary px-3 py-1 rounded text-sm">
                                Fetch More
                            </button>
                            <button onclick="refreshSingleFeed('${doc.id}')" class="themed-button-secondary px-3 py-1 rounded text-sm" id="refresh-${doc.id}">
                                Refresh
                            </button>
                            <button onclick="showEditFeedModal('${doc.id}', '${feedTitle}', '${feed.url}')" class="themed-button-secondary px-3 py-1 rounded text-sm">
                                Edit
                            </button>
                            <button onclick="deleteFeed('${doc.id}')" class="themed-button-danger px-3 py-1 rounded text-sm">
                                Remove
                            </button>
                        </div>
                    `;
                    manageFeedsList.appendChild(feedElement);
                });
            } catch (error) {
                console.error('Error loading RSS feeds:', error);
            }
        }

        // Refresh all feeds for new episodes
        async function refreshAllFeeds() {
            try {
                const rssCol = collection(db, 'rss_feeds');
                const rssSnapshot = await getDocs(rssCol);
                let totalNewEpisodes = 0;
                
                // Get existing episode URLs to avoid duplicates
                const podcastsCol = collection(db, 'podcasts-data', 'public', 'podcasts');
                const existingPodcasts = await getDocs(podcastsCol);
                const existingUrls = new Set();
                existingPodcasts.forEach(doc => {
                    existingUrls.add(doc.data().url);
                });
                
                for (const feedDoc of rssSnapshot.docs) {
                    const feed = feedDoc.data();
                    console.log('Refreshing feed:', feed.url);
                    
                    try {
                        // Parse feed with default limit of 5 newest episodes
                        const feedData = await parseRSSFeed(feed.url, 5);
                        const { episodes } = feedData;
                        let newEpisodes = 0;
                        
                        for (const episode of episodes) {
                            // Only add if not already in library
                            if (!existingUrls.has(episode.url)) {
                                await addDoc(collection(db, 'podcasts-data', 'public', 'podcasts'), {
                                    name: episode.title,
                                    description: episode.description,
                                    url: episode.url,
                                    artworkUrl: episode.artworkUrl,
                                    podcastTitle: episode.podcastTitle,
                                    uploadedAt: serverTimestamp(),
                                    playbackPosition: 0,
                                    duration: 0,
                                    isPlayed: false,
                                    source: 'rss'
                                });
                                existingUrls.add(episode.url);
                                newEpisodes++;
                            }
                        }
                        
                        totalNewEpisodes += newEpisodes;
                        
                        // Update feed's last checked timestamp
                        await updateDoc(doc(db, 'rss_feeds', feedDoc.id), {
                            lastChecked: serverTimestamp()
                        });
                        
                        console.log(`Found ${newEpisodes} new episodes from ${feed.url}`);
                        
                    } catch (error) {
                        console.error(`Failed to refresh feed ${feed.url}:`, error);
                    }
                }
                
                if (totalNewEpisodes > 0) {
                    loadRssEpisodes(); // Refresh the RSS episodes list
                    showNotification(`Found ${totalNewEpisodes} new episodes!`, 'success');
                } else {
                    showNotification('No new episodes found', 'info');
                }
                
                loadManageFeeds(); // Refresh the feeds list to show updated timestamps
                
            } catch (error) {
                console.error('Error refreshing feeds:', error);
                throw error;
            }
        }

        // Show fetch more episodes modal
        window.showFetchMoreModal = function(feedId, feedTitle, feedUrl) {
            fetchModalPodcastName.textContent = feedTitle;
            fetchMoreModal.classList.remove('hidden');
            
            // Store feed info for later use
            fetchMoreModal.dataset.feedId = feedId;
            fetchMoreModal.dataset.feedUrl = feedUrl;
            fetchMoreModal.dataset.feedTitle = feedTitle;
        }

        // Show edit feed modal
        window.showEditFeedModal = function(feedId, feedTitle, feedUrl) {
            const editFeedModal = document.getElementById('editFeedModal');
            const editFeedName = document.getElementById('editFeedName');
            const editFeedUrl = document.getElementById('editFeedUrl');
            
            editFeedModal.dataset.feedId = feedId;
            editFeedName.value = feedTitle;
            editFeedUrl.value = feedUrl;
            editFeedModal.classList.remove('hidden');
        }

        // Fetch older episodes
        async function fetchOlderEpisodes(feedId, feedUrl, feedTitle, count) {
            try {
                showNotification(`Fetching ${count} older episodes from ${feedTitle}...`, 'info');
                
                // Get existing episode URLs to avoid duplicates
                const podcastsCol = collection(db, 'podcasts-data', 'public', 'podcasts');
                const existingPodcasts = await getDocs(podcastsCol);
                const existingUrls = new Set();
                existingPodcasts.forEach(doc => {
                    existingUrls.add(doc.data().url);
                });
                
                // Parse feed with requested count
                const feedData = await parseRSSFeed(feedUrl, count);
                const { episodes } = feedData;
                let newEpisodes = 0;
                
                for (const episode of episodes) {
                    if (!existingUrls.has(episode.url)) {
                        await addDoc(collection(db, 'podcasts-data', 'public', 'podcasts'), {
                            name: episode.title,
                            description: episode.description,
                            url: episode.url,
                            artworkUrl: episode.artworkUrl,
                            podcastTitle: episode.podcastTitle,
                            uploadedAt: serverTimestamp(),
                            playbackPosition: 0,
                            duration: 0,
                            isPlayed: false,
                            source: 'rss'
                        });
                        newEpisodes++;
                    }
                }
                
                // Update feed's last checked timestamp
                await updateDoc(doc(db, 'rss_feeds', feedId), {
                    lastChecked: serverTimestamp()
                });
                
                loadManageFeeds();
                loadRssEpisodes();
                
                if (newEpisodes > 0) {
                    showNotification(`Successfully fetched ${newEpisodes} new episodes from ${feedTitle}!`, 'success');
                } else {
                    showNotification(`All ${count} episodes are already in your library`, 'info');
                }
                
            } catch (error) {
                console.error('Fetch older episodes failed:', error);
                showNotification(`Failed to fetch episodes: ${error.message}`, 'error');
            }
        }

        // Refresh single RSS feed - make it globally accessible
        window.refreshSingleFeed = async function(feedId) {
            const refreshBtn = document.getElementById(`refresh-${feedId}`);
            
            try {
                // Update button to show loading state
                if (refreshBtn) {
                    refreshBtn.textContent = 'Refreshing...';
                    refreshBtn.disabled = true;
                }
                
                const feedDoc = await getDoc(doc(db, 'rss_feeds', feedId));
                if (!feedDoc.exists()) {
                    showNotification('Feed not found', 'error');
                    return;
                }
                
                const feed = feedDoc.data();
                console.log('Refreshing single feed:', feed.url);
                
                // Get existing episode URLs to avoid duplicates
                const podcastsCol = collection(db, 'podcasts-data', 'public', 'podcasts');
                const existingPodcasts = await getDocs(podcastsCol);
                const existingUrls = new Set();
                existingPodcasts.forEach(doc => {
                    existingUrls.add(doc.data().url);
                });
                
                const feedData = await parseRSSFeed(feed.url, 5);
                const { episodes } = feedData;
                let newEpisodes = 0;
                
                for (const episode of episodes) {
                    if (!existingUrls.has(episode.url)) {
                        await addDoc(collection(db, 'podcasts-data', 'public', 'podcasts'), {
                            name: episode.title,
                            description: episode.description,
                            url: episode.url,
                            artworkUrl: episode.artworkUrl,
                            podcastTitle: episode.podcastTitle,
                            uploadedAt: serverTimestamp(),
                            playbackPosition: 0,
                            duration: 0,
                            isPlayed: false,
                            source: 'rss'
                        });
                        newEpisodes++;
                    }
                }
                
                // Update feed's last checked timestamp
                await updateDoc(doc(db, 'rss_feeds', feedId), {
                    lastChecked: serverTimestamp()
                });
                
                loadManageFeeds();
                if (newEpisodes > 0) {
                    loadRssEpisodes();
                    showNotification(`Found ${newEpisodes} new episodes from ${feed.title || feed.url}!`, 'success');
                } else {
                    showNotification(`No new episodes found for ${feed.title || feed.url}`, 'info');
                }
                
            } catch (error) {
                console.error('Single feed refresh failed:', error);
                showNotification(`Failed to refresh feed: ${error.message}`, 'error');
            } finally {
                // Reset button state
                if (refreshBtn) {
                    refreshBtn.textContent = 'Refresh';
                    refreshBtn.disabled = false;
                }
            }
        }

        // Delete RSS feed - make it globally accessible
        window.deleteFeed = async function(feedId) {
            console.log('Attempting to delete feed with ID:', feedId);
            
            if (!feedId || feedId === 'undefined' || feedId === 'null') {
                showNotification('Invalid feed ID', 'error');
                return;
            }
            
            try {
                const feedRef = doc(db, 'rss_feeds', feedId);
                await deleteDoc(feedRef);
                console.log('Feed deleted successfully:', feedId);
                
                // Immediately update the UI without page refresh
                loadManageFeeds();
                loadRssEpisodes();
                
                showNotification('RSS feed removed', 'success');
            } catch (error) {
                console.error('Error deleting feed:', error);
                console.error('Feed ID that failed:', feedId);
                if (error.code === 'permission-denied') {
                    showNotification('Permission denied. Check Firestore security rules.', 'error');
                } else if (error.code === 'not-found') {
                    showNotification('Feed not found. Refreshing list...', 'error');
                    loadRssFeeds();
                } else {
                    showNotification(`Failed to remove RSS feed: ${error.message}`, 'error');
                }
            }
        }

        // RSS Feed parsing function
        async function parseRSSFeed(url, limit = 5) {
            try {
                console.log('Parsing RSS feed:', url);
                
                // Try multiple CORS proxies for better reliability
                const proxies = [
                    `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
                    `https://corsproxy.io/?${encodeURIComponent(url)}`,
                    `https://cors-anywhere.herokuapp.com/${url}`
                ];
                
                let response;
                let text;
                
                for (const proxyUrl of proxies) {
                    try {
                        console.log('Trying proxy:', proxyUrl);
                        response = await fetch(proxyUrl);
                        if (response.ok) {
                            text = await response.text();
                            break;
                        }
                    } catch (e) {
                        console.log('Proxy failed:', e.message);
                        continue;
                    }
                }
                
                if (!text) {
                    throw new Error('Failed to fetch RSS feed from all proxies');
                }
                
                console.log('RSS feed content length:', text.length);
                
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(text, 'text/xml');
                
                // Check for parsing errors
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    console.error('XML parsing error:', parseError.textContent);
                    throw new Error('Invalid XML format');
                }
                
                // Extract podcast-level information
                const channel = xmlDoc.querySelector('channel') || xmlDoc.querySelector('feed');
                const podcastTitle = channel?.querySelector('title')?.textContent || 'Unknown Podcast';
                
                // Extract podcast artwork
                let podcastArtwork = null;
                const itunesImage = channel?.querySelector('itunes\\:image');
                if (itunesImage) {
                    podcastArtwork = itunesImage.getAttribute('href');
                }
                if (!podcastArtwork) {
                    const imageTag = channel?.querySelector('image url');
                    if (imageTag) {
                        podcastArtwork = imageTag.textContent;
                    }
                }
                
                console.log('Podcast title:', podcastTitle);
                console.log('Podcast artwork:', podcastArtwork);
                
                // Try multiple selectors for items (different RSS formats)
                let items = xmlDoc.querySelectorAll('item');
                if (items.length === 0) {
                    items = xmlDoc.querySelectorAll('entry'); // Atom feeds
                }
                
                console.log('Found items:', items.length);
                
                if (items.length === 0) {
                    throw new Error('No episodes found in feed');
                }
                
                const episodes = [];
                
                for (let i = 0; i < Math.min(items.length, limit); i++) {
                    const item = items[i];
                    
                    // Get title - try multiple selectors
                    let title = item.querySelector('title')?.textContent || 
                               item.querySelector('itunes\\:title')?.textContent ||
                               `Episode ${i + 1}`;
                    
                    // Get description - try multiple selectors
                    let description = item.querySelector('description')?.textContent || 
                                    item.querySelector('itunes\\:summary')?.textContent ||
                                    item.querySelector('content\\:encoded')?.textContent || 
                                    '';
                    
                    // Clean up description (remove HTML tags)
                    description = description.replace(/<[^>]*>/g, '').trim();
                    
                    // Get episode artwork (fallback to podcast artwork)
                    let episodeArtwork = podcastArtwork;
                    const episodeImage = item.querySelector('itunes\\:image');
                    if (episodeImage) {
                        episodeArtwork = episodeImage.getAttribute('href');
                    }
                    
                    // Look for audio enclosure - try multiple approaches
                    let audioUrl = null;
                    
                    // Method 1: Standard enclosure
                    const enclosure = item.querySelector('enclosure');
                    if (enclosure) {
                        const type = enclosure.getAttribute('type') || '';
                        if (type.includes('audio') || type.includes('mpeg') || type.includes('mp3')) {
                            audioUrl = enclosure.getAttribute('url');
                        }
                    }
                    
                    // Method 2: Media namespace
                    if (!audioUrl) {
                        const mediaContent = item.querySelector('media\\:content');
                        if (mediaContent) {
                            const type = mediaContent.getAttribute('type') || '';
                            if (type.includes('audio')) {
                                audioUrl = mediaContent.getAttribute('url');
                            }
                        }
                    }
                    
                    // Method 3: Link elements
                    if (!audioUrl) {
                        const links = item.querySelectorAll('link');
                        for (const link of links) {
                            const href = link.getAttribute('href') || link.textContent;
                            if (href && (href.includes('.mp3') || href.includes('.m4a') || href.includes('.wav'))) {
                                audioUrl = href;
                                break;
                            }
                        }
                    }
                    
                    if (audioUrl) {
                        episodes.push({
                            title: title.trim(),
                            description: description.substring(0, 200) + (description.length > 200 ? '...' : ''),
                            url: audioUrl.trim(),
                            artworkUrl: episodeArtwork,
                            podcastTitle: podcastTitle
                        });
                        console.log(`Found episode: ${title.trim()}`);
                    }
                }
                
                console.log('Successfully parsed episodes:', episodes.length);
                return { episodes, podcastTitle, podcastArtwork };
                
            } catch (error) {
                console.error('RSS parsing error:', error);
                throw new Error(`Failed to parse RSS feed: ${error.message}`);
            }
        }

        async function deletePodcast(id, storagePath) {
            try {
                if (storagePath && storagePath !== 'undefined' && storagePath !== 'null') {
                    const fileRef = ref(storage, storagePath);
                    await deleteObject(fileRef);
                }
            } catch (error) {
                console.warn(`Could not delete file from storage (it might already be gone): ${error.message}`);
            }
            await deleteDoc(doc(db, 'podcasts-data', 'public', 'podcasts', id));
        }

        function resetUploadUI() {
            fileInput.value = '';
            fileInput.disabled = false;
            const fileLabel = document.getElementById('fileLabel');
            if (fileLabel) {
                fileLabel.textContent = 'Choose an audio file to upload...';
                fileLabel.classList.remove('cursor-not-allowed', 'opacity-50');
            }
            setTimeout(() => {
                const progressContainer = document.getElementById('uploadProgressContainer');
                const progressBar = document.getElementById('uploadProgressBar');
                if (progressContainer) progressContainer.style.display = 'none';
                if (progressBar) progressBar.style.width = '0%';
                
                // Auto-close upload window after successful upload
                const uploadSection = document.getElementById('uploadSection');
                const showUploadFormBtn = document.getElementById('showUploadFormBtn');
                if (uploadSection && showUploadFormBtn) {
                    uploadSection.classList.add('hidden');
                    showUploadFormBtn.textContent = 'Add New Podcast';
                }
            }, 1000); // Wait 1 second to show completion before closing
        }

        document.body.addEventListener('click', e => {
            if (e.target.closest('.play-pause-btn')) handlePlayPause(e.target.closest('.play-pause-btn').dataset.id);
            if (e.target.closest('.restart-btn')) handleRestart(e.target.closest('.restart-btn').dataset.id);
            if (e.target.closest('.delete-btn')) handleDeleteRequest(e.target.closest('.delete-btn').dataset.id, podcastsData[e.target.closest('.delete-btn').dataset.id]?.storagePath);
            if (e.target.closest('.move-to-library-btn')) handleMoveToLibrary(e.target.closest('.move-to-library-btn').dataset.id);
        });

        let draggedItem = null;
        let isScrubbing = false;
        let scrubbedId = null;

        document.body.addEventListener('dragstart', e => {
            if (e.target.closest('.drag-handle')) {
                draggedItem = e.target.closest('.podcast-item');
                setTimeout(() => draggedItem.classList.add('dragging'), 0);
            }
        });

        document.body.addEventListener('dragend', e => {
            if (draggedItem) {
                draggedItem.classList.remove('dragging');
                draggedItem = null;
                updateOrderInFirestore();
            }
        });

        document.body.addEventListener('dragover', e => {
            e.preventDefault();
            const container = e.target.closest('#podcastListContainer');
            if(!container || !draggedItem) return;

            const afterElement = getDragAfterElement(container, e.clientY);
            if (afterElement == null) {
                container.appendChild(draggedItem);
            } else {
                container.insertBefore(draggedItem, afterElement);
            }
        });
        
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.podcast-item:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        async function updateOrderInFirestore() {
            const batch = writeBatch(db);
            const items = podcastListContainer.querySelectorAll('.podcast-item');
            items.forEach((item, index) => {
                const docRef = doc(db, 'podcasts-data', 'public', 'podcasts', item.dataset.id);
                batch.update(docRef, { order: index });
            });
            await batch.commit();
            showNotification('Playlist order saved!', 'success');
        }

        function handleScrub(id, event) {
            event.preventDefault(); 
            const podcast = podcastsData[id];
            if (!podcast || !podcast.duration) return;
            const progressBarWrapper = document.querySelector(`[data-id="${id}"] .progress-bar-wrapper`);
            if(!progressBarWrapper) return;
            const rect = progressBarWrapper.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clickX = clientX - rect.left;
            let newPosition = (clickX / rect.width) * podcast.duration;
            if (newPosition < 0) newPosition = 0;
            if (newPosition > podcast.duration) newPosition = podcast.duration;
            
            if (id === currentPlayingId) {
                audioPlayer.currentTime = newPosition;
            }
            podcastsData[id].playbackPosition = newPosition;
            updateSinglePodcastUI(id);
            if(!isScrubbing) {
                 updatePlaybackPosition(id, newPosition);
            }
        }
        
        document.body.addEventListener('mousedown', (e) => {
            const wrapper = e.target.closest('.progress-bar-wrapper');
            if (wrapper) {
                isScrubbing = true;
                scrubbedId = wrapper.dataset.id;
                handleScrub(scrubbedId, e);
            }
        });
         document.body.addEventListener('touchstart', (e) => {
            const wrapper = e.target.closest('.progress-bar-wrapper');
            if (wrapper) {
                isScrubbing = true;
                 scrubbedId = wrapper.dataset.id;
                handleScrub(scrubbedId, e);
            }
        });

        document.body.addEventListener('mousemove', (e) => {
            if (isScrubbing) {
                 if(scrubbedId) handleScrub(scrubbedId, e);
            }
        });
        document.body.addEventListener('touchmove', (e) => {
            if (isScrubbing) {
                const touch = e.touches[0];
                const element = document.elementFromPoint(touch.clientX, touch.clientY);
                 const wrapper = element.closest('.progress-bar-wrapper');
                 if(wrapper) handleScrub(wrapper.dataset.id, e);
            }
        });


        document.body.addEventListener('mouseup', () => {
            if(isScrubbing && scrubbedId) {
                updatePlaybackPosition(scrubbedId, podcastsData[scrubbedId].playbackPosition);
            }
            isScrubbing = false;
            scrubbedId = null;
        });
        document.body.addEventListener('touchend', () => {
             if(isScrubbing && scrubbedId) {
                updatePlaybackPosition(scrubbedId, podcastsData[scrubbedId].playbackPosition);
            }
            isScrubbing = false;
            scrubbedId = null;
        });

        function handleDeleteRequest(id, storagePath) {
             const confirmDelete = document.getElementById('confirmDelete');
             const cancelDelete = document.getElementById('cancelDelete');
             const podcastNameToDelete = document.getElementById('podcastNameToDelete');
             
             podcastNameToDelete.textContent = podcastsData[id]?.name || 'this podcast';
             deleteModal.classList.remove('hidden');

             const confirmHandler = async () => {
                confirmDelete.disabled = true;
                confirmDelete.textContent = "Deleting...";
                try {
                    if (currentPlayingId === id) { audioPlayer.pause(); audioPlayer.src = ''; currentPlayingId = null; }
                    await deletePodcast(id, storagePath);
                    showNotification("Podcast deleted.", "success");
                } catch (error) {
                    showNotification("Failed to delete podcast.", "error");
                    console.error("Delete failed:", error);
                } finally {
                    deleteModal.classList.add('hidden');
                    confirmDelete.disabled = false;
                    confirmDelete.textContent = "Delete";
                }
             };
             
             confirmDelete.onclick = confirmHandler;
             cancelDelete.onclick = () => deleteModal.classList.add('hidden');
        }

        function handleMoveToLibrary(id) {
             updateDoc(doc(db, 'podcasts-data', 'public', 'podcasts', id), { isPlayed: false, order: Object.keys(podcastsData).length });
        }
        
        function handleRestart(id) {
            if (id === currentPlayingId) {
                audioPlayer.currentTime = 0;
            }
            podcastsData[id].playbackPosition = 0;
            updateSinglePodcastUI(id);
            updatePlaybackPosition(id, 0);
        }

        function handlePlayPause(id) {
            const podcast = podcastsData[id];
            if (!podcast) return;

            if (podcast.isPlayed) {
                updateDoc(doc(db, 'podcasts-data', 'public', 'podcasts', id), { isPlayed: false, playbackPosition: 0 });
            }

            const isCurrentlyPlaying = !audioPlayer.paused;
            const isThisPodcastPlaying = isCurrentlyPlaying && currentPlayingId === id;
            
            if (isThisPodcastPlaying) {
                audioPlayer.pause();
                updateSinglePodcastUI(id);
            } else {
                const oldPlayingId = currentPlayingId;
                currentPlayingId = id;
                if (oldPlayingId && oldPlayingId !== id) {
                    updateSinglePodcastUI(oldPlayingId);
                }

                if (audioPlayer.src !== podcast.url) {
                    audioPlayer.src = podcast.url;
                    audioPlayer.load();
                }
                
                audioPlayer.currentTime = podcast.playbackPosition;
                audioPlayer.play().catch(e => console.error("Play error:", e));
                updateSinglePodcastUI(id);
            }
        }
        
        audioPlayer.addEventListener('loadedmetadata', async () => {
            if (!currentPlayingId || !podcastsData[currentPlayingId]) return;
            
            const podcast = podcastsData[currentPlayingId];
            const audioDuration = audioPlayer.duration;
            
            // Update duration if it's missing (common for RSS episodes) and duration is valid
            if (podcast.duration === 0 && !isNaN(audioDuration) && audioDuration > 0) {
                podcast.duration = audioDuration;
                podcastsData[currentPlayingId].duration = audioDuration;
                
                // Update in Firebase
                try {
                    await updateDoc(doc(db, 'podcasts-data', 'public', 'podcasts', currentPlayingId), {
                        duration: audioDuration
                    });
                    console.log(`Updated duration for ${podcast.name}: ${audioDuration}s`);
                } catch (error) {
                    console.error('Failed to update duration in Firebase:', error);
                }
                
                // Refresh UI to show correct duration
                updateSinglePodcastUI(currentPlayingId);
            }
        });

        audioPlayer.addEventListener('timeupdate', () => {
            if (!currentPlayingId || !podcastsData[currentPlayingId] || isScrubbing) return;
            const newPosition = audioPlayer.currentTime;
            podcastsData[currentPlayingId].playbackPosition = newPosition;
            updateSinglePodcastUI(currentPlayingId);
            clearTimeout(updateTimer);
            updateTimer = setTimeout(() => updatePlaybackPosition(currentPlayingId, newPosition), 3000);
        });
        
        audioPlayer.addEventListener('ended', () => {
            if (!currentPlayingId) return;
            const oldPlayingId = currentPlayingId;
            
            if (isRepeat) {
                audioPlayer.currentTime = 0;
                audioPlayer.play();
                return;
            }
            
            updateDoc(doc(db, 'podcasts-data', 'public', 'podcasts', oldPlayingId), { isPlayed: true, playbackPosition: 0 });
            
            const activePlaylist = Array.from(document.querySelectorAll('#podcastListContainer .podcast-item')).map(item => item.dataset.id);
            if (activePlaylist.length <= 1 && !isShuffle) return;

            if (isShuffle) {
                let unplayed = activePlaylist.filter(id => id !== oldPlayingId);
                if(unplayed.length > 0) {
                    let randomIndex = Math.floor(Math.random() * unplayed.length);
                    handlePlayPause(unplayed[randomIndex]);
                }
            } else {
                 const currentIndex = activePlaylist.indexOf(oldPlayingId);
                 const nextIndex = currentIndex + 1;
                 if (nextIndex < activePlaylist.length) {
                    const nextPodcastId = activePlaylist[nextIndex];
                    handlePlayPause(nextPodcastId);
                 }
            }
        });
        
        async function updatePlaybackPosition(id, position) {
            if (!userId || !firebaseAppInitialized) return;
            const docRef = doc(db, 'podcasts-data', 'public', 'podcasts', id);
            try {
                await updateDoc(docRef, { playbackPosition: position });
                if(podcastsData[id]) podcastsData[id].playbackPosition = position;
            } catch(e) {
                console.warn("Could not update playback position:", e.message);
            }
        }

        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return '00:00';
            const d = new Date(seconds * 1000);
            return `${d.getUTCHours() > 0 ? d.getUTCHours()+':' : ''}${d.getUTCMinutes().toString().padStart(2, '0')}:${d.getUTCSeconds().toString().padStart(2, '0')}`;
        }
        function showNotification(message, type = "success") {
            messageText.textContent = message;
            messageBox.className = `fixed bottom-24 right-5 text-white py-2 px-4 rounded-lg shadow-lg transition-opacity duration-300 z-50 ${type === 'error' ? 'bg-red-500' : 'bg-green-500'}`;
            messageBox.classList.remove('opacity-0');
            setTimeout(() => messageBox.classList.add('opacity-0'), 3000);
        }
    </script>
</body>
</html>
